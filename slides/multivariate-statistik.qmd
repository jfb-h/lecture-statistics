---
title: "Einführung in die Statistik"
subtitle: "Zusammenhangsmaße"
author: Dr. Jakob Hoffmann, Economic Geography Group
lightbox: true
execute:
    cache: true
    keep-ipynb: false
    keep-md: false
filters:
    - parse-latex
format:
    revealjs:
        css: custom.css
        controls: true
        slide-number: true
        # embed-resources: true
        # chalkboard:
        #     theme: whiteboard
        #     boardmarker-width: 2
---

```{r}
#| cache: false

library(rlang)
library(dplyr)
library(tidyr)
library(readr)
library(lubridate)
library(stringr)
library(forcats)
library(ggplot2)
library(ggthemes)
library(ggridges)
library(viridis)
library(patchwork)
library(srvyr)
library(posterior)

theme_set(theme_tufte(base_family="Arial"))

theme_update(
  axis.title.x = element_text(hjust = 0.99),
  axis.title.y = element_text(hjust = 0.99),
  plot.title = element_text(face = "bold"),
  plot.caption = element_text(face="italic"),
  strip.text.x = element_text(hjust = 0.01, face = "bold"),
  strip.text.y = element_text(vjust = 0.01, face = "bold"),
  legend.position = "top",
  legend.justification.top = "left"
)

```

##  {background-iframe="https://surveys.eggroup-lmu.de/statlecture/measures/results" background-interactive="true" data-preload="true"}

# Fallstudie
Vertrauen in Politik und Wissenschaft in Europa

## Vertrauen in Politik und Wissenschaft

![](images/trst-pol-sci.png)

# Fallstudie
Temperaturen in München, 1973 - 2023

## Daten

:::: {.columns}
::: {.column width="40%"}
```{r}
# library(GSODR)
# data = get_GSOD(years=2013:2023, station="108660-99999") |> select(YEAR, MONTH, DAY, TEMP)
# data$MONTH = lubridate::month(data$MONTH, label=T, abbr=T)
# arrow::write_parquet(data, "data/temp_munich.parquet")

data = arrow::read_parquet("data/temp_munich.parquet") |>
  mutate(date = lubridate::make_date(YEAR, MONTH, DAY))

data |>
  select(YEAR:TEMP) |>
  head(10) |>
  knitr::kable() |>
  kableExtra::kable_styling(font_size=24)

```
:::
::: {.column width="60%"}
Temperaturdaten werden von tausenden Messstationen weltweit erfasst und in aggregierter Form veröffentlicht, wie z.B. in der Global Summary of the Day (GSOD).

```{.r}
libary(GSODR)

get_GSOD(
  years=2013:2023,
  station="108660-99999"
)

```
:::
::::

## Tagestemperaturen

<!-- <div style="width:11in; height:6in; background-color: rgba(0, 128, 0, 0.5)">test</div> -->

```{r, fig.width=11, fig.height=6}
cal = data |>
  filter(year(date) == 2023) |>
  mutate(
    month = month(date, label=TRUE),
    week = week(date),
    day = day(date),
    weekday = fct_inorder(weekdays(date, abbreviate=TRUE)),
    ) |>
  mutate(month=factor(month, levels=unique(month))) |>
  group_by(month) |>
  mutate(
    weekmonth = data.table::frank(week, ties.method="dense")
  )

limit <- max(abs(cal$TEMP)) * c(-1, 1)

ggplot(cal, aes(x = weekday, y = weekmonth, fill = TEMP)) +
  geom_tile(color="white") +
  geom_text(aes(label=day), size = 2) +
  facet_wrap(~month, scales="free_x", ncol=3) +
  scale_x_discrete() +
  scale_y_reverse(breaks=NULL) +
  scale_fill_distiller(palette="RdBu", type="div", limit = limit) +
  guides(fill=guide_colorbar(barwidth=0.7, barheight=10)) +
  labs(
    title = "Temperaturen im Jahresverlauf, München 2023",
    subtitle = "Durchschnittliche Tagestemperatur",
    x=NULL,
    y=NULL,
    fill = "Temp.",
    caption = "Datenquelle: GSOD"
  ) +
  theme(legend.position="right")
```

## Tagestemperaturen

```{r, fig.width=11, fig.height=6}

data |>
  group_by(MONTH, DAY) |>
  summarize(am=mean(TEMP), sd=sd(TEMP)) |>
  arrange(MONTH, DAY) |>
  ungroup() |>
  mutate(x=1:n()) |>
  ggplot(aes(x, am, color=am)) +
  geom_hline(yintercept=0) +
  geom_point(size=0.5) +
  geom_linerange(aes(ymin=am - sd, ymax = am + sd)) +
  scale_color_distiller(palette="RdBu", type="div", limit = limit) +
  guides(color=guide_colorbar(barwidth=10, barheight=0.5)) +
  labs(
    x = "Tag", y = "Temperatur (°C)", color = NULL,
    title = "Temperaturen im Jahresverlauf, München 1973 - 2023",
    subtitle = "Tagesweise aggregierte arithmetische Mittel ± Standardabweichungen",
    caption = "Datenquelle: GSOD"
    ) +
  theme(
    panel.background=element_rect(fill="grey30"),
    # plot.background=element_rect(fill="grey90", color="transparent"),
  )

```

## Mittelwert und Abweichung

```{r, fig.width=10, fig.height=3}

data |>
  summarize(
    am=mean(TEMP),
    sd=sd(TEMP)
  ) |>
  ggplot() +
  geom_linerange(
    aes(y=1, x=am, xmin=am-sd, xmax=am+sd),
    linewidth=2
  ) +
  geom_point(
    aes(y=1, x=am),
    size = 12
  ) +
  geom_text(
    aes(x=am, y=1, label="Arithmetisches\nMittel (x̄)"),
    nudge_y=-0.3, size=8, color="grey60", vjust=1
  ) +
  geom_text(
    aes(x=am-sd, y=1, label="x̄ - s"),
    nudge_y=-0.3, size=8, color="grey60", vjust=1
  ) +
  geom_text(
    aes(x=am+sd, y=1, label="x̄ + s"),
    nudge_y=-0.3, size=8, color="grey60", vjust=1
  ) +
  lims(
    x=c(-3, 18),
    y=c(0, 2)
  ) +
  theme_void()

```

Der Punkt kann auch ein anderes Lagemaß darstellen, der Strich eine andere Form der Abweichung (z.B. Standardfehler).


## Tagestemperaturen

```{r, fig.width=11, fig.height=6}

data |>
  ggplot(aes(x=factor(week(date)), y=TEMP)) +
  geom_hline(yintercept=0) +
  geom_boxplot(fill="tomato", outlier.size=0.6) +
  scale_color_distiller(
    palette="RdBu", type="div", limit = limit
  ) +
  guides(color=guide_colorbar(barwidth=10, barheight=0.5)) +
  labs(
    x = "Woche", y = "Temperatur (°C)", color = NULL,
    title = "Temperaturen im Jahresverlauf, München 1973 - 2023",
    subtitle = "Wochenweise aggregierte Boxplots",
    caption = "Datenquelle: GSOD"
    )

```

## Temperaturen

```{r, fig.width=11, fig.height=6}

limit <- max(abs(data$TEMP)) * c(-1, 1)

ggplot(data, aes(x = TEMP, y = fct_rev(MONTH), fill=stat(x))) +
    geom_density_ridges_gradient(
          scale=4, rel_min_height=0.01, gradient_lwd = 1.0
      ) +
    scale_y_discrete(expand=c(0,0)) +
    scale_x_continuous(expand=c(0,0)) +
    # scale_fill_viridis_c(name="Temp. (°C)") +
    scale_fill_distiller(palette="RdBu", type="div", limit = limit) +
    guides(color=guide_colorbar(barwidth=10, barheight=0.5)) +
    coord_cartesian(clip="off") +
    labs(
      # title="Monatsweise Temperaturen in München",
      title="Temperaturen im Jahresverlauf, München 1973 - 2023",
      subtitle = "Monatsweise aggregierte Kerndichtediagramme",
      y="",
      x="Temperatur (°C)",
      caption = "Datenquelle: GSOD"
    ) +
    theme_ridges() +
    theme(legend.position="none")
```

## Kerndichtediagramme

Kerndichtediagramme sind eine kontinuierliche Variante des diskreten Histogramms. Das KDD gibt relative Häufigkeiten statt absolute Häufigkeiten in einem Wertebereich an.

```{r fig.width=11, fig.height=4}
set.seed(321)

sim = data.frame(
  x = rnorm(10000, mean=170, sd=8)
  )

dens = density(sim$x)
dens = tibble(x=dens$x, y=dens$y)

ggplot(sim, aes(x=x, y=after_stat(density))) +
  geom_histogram(fill="grey70", color="white", binwidth=2) +
  geom_area(
    data = filter(dens, x > 170),
    aes(x=x, y=y),
    fill = "tomato",
    alpha = 0.5
  ) +
  geom_line(
    data=dens,
    aes(x=x, y=y),
    linewidth=2
    ) +
  labs(
    x=NULL, y="Dichte",
  )
```


## Tagestemperaturen

```{r fig.width=11, fig.height=6}

td = data |>
  group_by(YEAR, MONTH) |>
  summarize(am=mean(TEMP))

td |>
  ggplot() +
  geom_hline(yintercept=0) +
  geom_line(
    aes(x=MONTH, y=am, group=YEAR),
    linewidth=0.1,
    color="grey80",
    alpha=0.7
  ) +
  geom_point(
    aes(x=MONTH, y=am, group=YEAR, color=am),
  ) +
  geom_line(
    aes(x=MONTH, y=am, group=YEAR, color=am),
    data=filter(td, YEAR==2023),
    color="grey20"
  ) +
  geom_point(
    aes(x=MONTH, y=am, group=YEAR, color=am),
    data=filter(td, YEAR==2023),
    color="grey20",
  ) +
  geom_point(
    data = summarize(group_by(td, MONTH), y=mean(am)),
    aes(x=MONTH, y=y),
    color = "grey20",
    shape = "-",
    size = 12
    ) +
  geom_text(
    data=filter(td, YEAR == 2023, MONTH == "Dec"),
    aes(x=MONTH, y=am, label="2023"), size=3, nudge_x=0.3) +
  scale_color_distiller(
    palette="RdBu", type="div", limit = limit
  ) +
  guides(color=guide_colorbar(barwidth=10, barheight=0.5)) +
  labs(
    x = NULL, y = "Temperatur (°C)", color = NULL,
    title = "Temperaturen im Jahresverlauf, München 1973 - 2023",
    subtitle = "Verbundene Punkte zeigen mittlere Monatstemperaturen für jedes Jahr,\nMarkierungen die mittleren Monatstemperaturen über die letzten 50 Jahre.",
    caption = "Datenquelle: GSOD"
    )

```

# Deskriptive Statistik II
Multivariate Visualisierung und Zusammenhangsmaße

## Bisher: Univariate Verteilungen

```{r, fig.width=11, fig.height=6}

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

d1 = tibble(
  x=rlnorm(1000, meanlog = 8, sdlog = 0.3)
)

p1 = d1 |> ggplot(aes(x)) +
  # geom_histogram(aes(y=..density..), fill="grey70") +
  geom_hline(yintercept=0) +
  geom_density(linewidth=1.5, color="grey40") +
  geom_vline(xintercept=median(d1$x), color="tomato", linewidth=2) +
  labs(y=NULL, x=NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

d2 = tibble(
  x = fct_infreq(sample(LETTERS[1:5], 100, replace=TRUE))
)

p2 = d2 |> ggplot(aes(x)) +
  geom_bar(fill="grey70") +
  geom_bar(data = filter(d2, x == getmode(x)), fill="tomato") +
  geom_hline(yintercept=0) +
  labs(y=NULL, x=NULL) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

p1 / p2
```

## Jetzt: Multivariate Verteilungen

```{r, fig.width=11, fig.height=6}
N <- 2000
k <- 6

g <- factor(sample(1:k, N, replace=T), labels=paste0("Gruppe ", 1:k))
z <- factor(sample(1:2, N, replace=T), labels=LETTERS[25:26])
x <- rnorm(N) + ifelse(z == "Z", rnorm(N, -1), rnorm(N, 1))

a <- rnorm(k)
b <- rnorm(k)
d <- c(1,2)

y <- a[g] + b[g]*x + d[z] + rnorm(N, sd=2)

data_sim <- tibble(y, x, g, z)

data_sim |>
  ggplot(aes(x=x, y=y)) + 
  geom_hline(yintercept=0, color="grey60", linewidth=0.3) +
  geom_vline(xintercept=0, color="grey60", linewidth=0.3) +
  geom_point(aes(color=z), shape=1) +
  scale_color_tableau() +
  geom_smooth(method="lm", color="grey20", se=FALSE, linewidth=1) +
  facet_wrap(~g) +
  labs(color=NULL, x="", y="") +
  theme(legend.position="none")
```


## Multivariate Statistik

- Die meisten wissenschaftlichen Fragestellungen betreffen das Zusammenspiel von zwei oder mehr Variablen.

- Multivariate Verfahren dienen der *Identifikation* von bisher unbekannten oder der *Überprüfung* von vermuteten statistischen Zusammenhängen zwischen Variablen.

- Die beteiligten Variablen spielen in multivariaten Verfahren oft (aber nicht immer) unterschiedliche Rollen (z.B. Explanans, Explanandum, Kontrollvariable).



## Variablentypen

- Die **abhängige Variable** und ihre Variation zu Verstehen ist das primäre Untersuchungsziel einer multivariaten Analyse.

- **Unabhängige Variablen** dienen der Erklärung oder Vorhersage von Variation in der abhängigen Variable. Die Variation der
unabhängigen Variable selbst wird i.d.R. als gegeben angesehen oder experimentell manipuliert.

- **Kontrollvariablen** dienen der Vermeidung von verzerrten Schlussfolgerungen über den Zusammenhang zwischen unabhängigen und abhängigen Variablen.


## Variablentypen

**Untersuchungsziel**: Gender Pay Gap

```{dot}
//| fig-width: 10
//| fig-height: 5

digraph G {
  layout=dot
  rankdir=LR

  node [
    shape=rect
    color="#FF8C00"
    style="filled,rounded"
    fontname="Helvetica,Arial,sans-serif"
    fontcolor="#FFFFFF"
    width=1.2
    height=0.6
    margin=0.2
  ]

  edge [
    color="#555555"
    penwidth=2
  ]

  {
    rank=same;
    A[label="Unabhängige Variable\n(Geschlecht)"];
    B[label="Abhängige Variable\n(Gehalt)"];
  }
  C[label="Kontrollvariable(n)\n(z.B. Beruf)" color=lightgrey fontcolor="#333333"];

  A -> B;
  A -> C;
  C -> B;
}
```

## Variablentypen

Wir beschreiben die abhängige Variable (AV, Output) auch oft als eine *Funktion* der unabhängigen Variable(UV, Input):

$$\textrm{AV} = f(\textrm{UV}) \color{lightgrey}{+ \epsilon}$$

bzw. mit Kontrollvariablen (KV):

$$\textrm{AV} = f(\textrm{UV, KV}) \color{lightgrey}{+ \epsilon}$$

Die exakte Spezifikation der Funktion $f$ hängt von den Daten, der Forschungsfrage und dem Forschungsdesign ab.


## Was ist die abhängige Variable?

```{r, fig.width=11, fig.height=6}

data |>
  ggplot(aes(x=factor(week(date)), y=TEMP)) +
  geom_hline(yintercept=0) +
  geom_boxplot(fill="tomato", outlier.size=0.6) +
  scale_color_distiller(
    palette="RdBu", type="div", limit = limit
  ) +
  guides(color=guide_colorbar(barwidth=10, barheight=0.5)) +
  labs(
    x = "Woche", y = "Temperatur (°C)", color = NULL,
    title = "Temperaturen im Jahresverlauf, München 1973 - 2023",
    subtitle = "Wochenweise aggregierte Boxplots",
    caption = "Datenquelle: GSOD"
    )

```

## Was ist die abhängige Variable?

![](images/trst-pol-sci.png)


## (Un)supervised learning {.smaller}

::::: columns
::: {.column width="50%"}

```{r, fig.width=5, fig.height=6}

library(mvtnorm)
library(ggforce)
library(purrr)

set.seed(123)

S = list(
  list(id = "a", n=500, s=c(20, 15)),
  list(id = "b", n=900, s=c(10, 10)),
  list(id = "c", n=700, s=c(12, 25))
)

df_clust = map(S, function(s) {
  x = rmvnorm(s$n, s$s, sigma=diag(c(3,2)))
  colnames(x) = c("x", "y")
  as_tibble(x) |> mutate(g = s$id)
}) |> list_rbind()

df_clust |>
ggplot(aes(x, y, color=g)) +
  geom_point(color="grey20", alpha=0.5, size=0.5) +
  geom_mark_hull(
    concavity = 100
  ) +
  lims(x=c(0, 30), y=c(0, 30)) +
  labs(x=NULL, y=NULL) +
  theme(legend.position = "none")

```

:::
::: {.column width="50%"}
- Nicht alle multivariaten Analysen haben asymmetrische Variablenrollen.
- Ein prominentes Beispiel ist die *Clusteranalyse*, die zum Ziel hat, latente (unbeobachtete) Gruppen zu identifizeren.
- Im Machine Learning wird zwischen *supervised learning* (Vorhersage einer bekannten und beobachteten Variable) und *unsupervised learning* (Identifikation von latenten Mustern) unterschieden.
:::
:::::

# Zusammenhangsmaße
Numerische Variablen

## Streudiagramm

```{r, fig.width=11, fig.height=6}
library(gapminder)

gapminder |>
  filter(year==2007) |>
  ggplot(aes(log10(gdpPercap), lifeExp)) +
  # geom_hline(yintercept=0, color="grey60", linewidth=0.3) +
  # geom_vline(xintercept=0, color="grey60", linewidth=0.3) +
  geom_point(shape=1, color="tomato") +
  scale_x_continuous(
      breaks = c(1,2,3,4,5),
      labels = scales::math_format(10^.x)
  ) +
  labs(
    x = "BIP (Log-Skala)",
    y = "Lebenserwartung (Jahre)",
    title = "Lebenserwartung und BIP",
    subtitle = "Daten für 142 Länder im Jahr 2007",
    caption = "Datenquelle: gampinder.org"
  )

```

## Kovarianz

```{r, fig.width=11, fig.height=6}
set.seed(123)

set.seed(123)
d_cov = tibble(
  x = rnorm(10),
  y = x + rnorm(10)
)
pts = tibble(
  x = c(1.0),
  y = c(2.5)
)

dat = rbind(d_cov, pts)
x_mean <- mean(dat$x)
y_mean <- mean(dat$y)
dat$color = factor(
  ((dat$x - x_mean) * (dat$y - y_mean)) > 0,
  levels = c(TRUE, FALSE),
  labels=c("pos", "neg")
)

dat |>
  ggplot(aes(x, y)) +
  geom_hline(yintercept = y_mean, color = "grey60", linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = x_mean, color = "grey60", linetype = "dashed", linewidth = 0.3) +
  annotate("text",
    x = x_mean + 0.05, y = max(dat$y), label = "x̄",
    size = 6, color = "grey60", vjust = 1
  ) +
  annotate("text",
    y = y_mean - 0.05, x = max(dat$x), label = "ȳ",
    size = 6, color = "grey60", vjust = 1
  ) +
  annotate("segment",
    x = x_mean, xend = pts$x, y = pts$y, yend = pts$y, color = "cornflower blue"
  ) +
  annotate("segment",
    y = y_mean, yend = pts$y, x = pts$x, xend = pts$x, color = "cornflower blue"
  ) +
  annotate("text",
    x = 0.55, y = 2.7, label = "(xᵢ - x̄)", color = "cornflower blue", size = 6
  ) +
  annotate("text",
    x = 1.12, y = 1.3, label = "(yᵢ - ȳ)", color = "cornflower blue", size = 6
  ) +
  geom_point(shape = 1, color = "black", stroke = 2) +
  labs(x = NULL, y = NULL)

```

## Kovarianz

```{r, fig.width=11, fig.height=6}
set.seed(123)
d_cov = tibble(
  x = rnorm(10),
  y = x + rnorm(10)
)
pts = tibble(
  x = c(1.0),
  y = c(2.5)
)

dat = rbind(d_cov, pts)
x_mean <- mean(dat$x)
y_mean <- mean(dat$y)
dat$color = factor(
  ((dat$x - x_mean) * (dat$y - y_mean)) > 0,
  levels = c(TRUE, FALSE),
  labels=c("pos", "neg")
)

dat |>
  ggplot(aes(x, y)) +
  annotate("rect", xmin = -Inf, xmax = x_mean, ymin = y_mean, ymax = Inf,  fill = "#dce8f5") +
  annotate("rect", xmin = x_mean, xmax = Inf, ymin = -Inf, ymax = y_mean,  fill = "#dce8f5") +
  annotate("rect", xmin = -Inf, xmax = x_mean, ymin = -Inf, ymax = y_mean, fill = "#f5e1dc") +
  annotate("rect", xmin = x_mean, xmax = Inf, ymin = y_mean, ymax = Inf,   fill = "#f5e1dc") +
  geom_hline(yintercept = y_mean, color = "grey60", linetype = "dashed", linewidth = 0.3) +
  geom_vline(xintercept = x_mean, color = "grey60", linetype = "dashed", linewidth = 0.3) +
  annotate("text",
    x = -0.6, y = -1.8,
    label = "(xᵢ - x̄)(yᵢ - ȳ)\nist positiv",
    size = 6, color = "darkred", vjust = 1
  ) +
  annotate("text",
    x = -0.6, y = 2.4,
    label = "(xᵢ - x̄)(yᵢ - ȳ)\nist negativ",
    size = 6, color = "navyblue", vjust = 1
  ) +
  annotate("text",
    x = x_mean + 0.05, y = max(dat$y), label = "x̄",
    size = 6, color = "grey60", vjust = 1
  ) +
  annotate("text",
    y = y_mean - 0.05, x = max(dat$x), label = "ȳ",
    size = 6, color = "grey60", vjust = 1
  ) +
  geom_point(aes(color = color), shape = 1,  stroke = 2) +
  scale_color_manual(values=c("darkred", "navyblue")) +
  labs(x = NULL, y = NULL) +
  theme(legend.position="none")

```

## Kovarianz

Analog zur Varianz ist die *Kovarianz* zweier Variablen $x$ und $y$ definiert als der Mittelwert der Produkte der Abweichungen von den jeweiligen Mittelwerten:

$$s_{xy} = \frac{1}{n} \sum_{i=1}^n (x_i - \bar{x}) (y_i - \bar{y})$$

Die Kovarianz ist positiv (negativ) wenn höhere Werte von $x$ mit höheren (niedrigeren) Werten von $y$ einhergehen.

## Kovarianz

Die Kovarianz zweier Variablen $x$ und $y$ ist symmetrisch (d.h. es gibt keine abhängige und unabhängige Variable):

$$s_{xy} = s_{yx}$$

Die Kovarianz ist zwar invariant unter der Addition von Konstanten, wird aber durch Faktoren der Variablen skaliert:

$$s_{ax + b, cy + d} = a \cdot c \cdot s_{xy}$$

Abhängigkeit von der Skalierung der Variablen macht die Kovarianz schwierig zu interpretieren / zu vergleichen.


## Korrelationskoeffizient

Normalisierung der Kovarianz durch das 'Herausteilen' der Standardabweichungen der beiden Variablen gibt uns den *Korrelationskoeffizienten* mit Wertebereich -1 bis 1:

$$
r_{xy} = \frac{s_{xy}}{s_x s_y}
$$

Die Normalisierung auf den Bereich -1 bis 1 kann durch die Cauchy-Schwarz-Ungleichung oder durch Anwendung der Kosinusdefinition des Skalarprodukts bewiesen werden.


## Korrelationskoeffizient

Für die beiden Datenreihen

$$
\begin{align}
\color{orange}{x = 1{,}4 \quad 2{,}3 \quad 1{,}1 \quad 2{,}7 \quad}
\color{cornflowerblue}{y = 5{,}3 \quad 4{,}3 \quad 0{,}4 \quad 4{,}8}
\end{align}
$$

ist die Kovarianz:
$\color{green}{s_{xy}} = \frac{1}{n}
\sum_{i=1}^n \color{orange}{(x_i - \bar{x})} \color{cornflowerblue}{(y_i - \bar{y})} = 1{,}04$

<br>

:::{.fragment}
Mit Standardabweichungen $\color{orange}{s_x = 0{,}75}$ und $\color{cornflowerblue}{s_y = 2{,}28}$ ist der Korrelationskoeffizient:

$$r_{xy} = \frac{\color{green}{s_{xy}}}{\color{orange}{s_x} \color{cornflowerblue}{s_y}} = 0.61$$
:::


## Korrelationskoeffizient

```{r, fig.width=11, fig.height=6}
set.seed(123)
n = 2000
rdf = rbind(
  tibble(g = LETTERS[1], x=rnorm(n, mean = 170, sd = 5), y=rnorm(n, mean = 170, sd = 5)),
  tibble(g = LETTERS[2], x=rnorm(n, mean = 170, sd = 5), y= 1.0 * x + rnorm(n, sd = 5)),
  tibble(g = LETTERS[3], x=rnorm(n, mean = 170, sd = 5), y=-1.0 * x + rnorm(n, sd = 5)),
  tibble(g = LETTERS[4], x=rnorm(n, mean = 170, sd = 5), y= 0.4 * x + rnorm(n, sd = 5))
) |>
  mutate(
    mx = mean(x),
    my=mean(y),
    color = factor(
      ((x - mean(x)) * (y - mean(y)) > 0),
      levels = c(TRUE, FALSE),
      labels=c("pos", "neg")
    ),
    .by=g
  )

cov_sum = function(df) {
  x = df$x
  y = df$y
  paste0(
    "Kovarianz = ",
    round(cov(x, y), digits=2), " | ",
    "Korrelation = ",
    round(cor(x, y), digits=2)
  )
}

labels = c(
  "A" = filter(rdf, g == "A") |> cov_sum(),
  "B" = filter(rdf, g == "B") |> cov_sum(),
  "C" = filter(rdf, g == "C") |> cov_sum(),
  "D" = filter(rdf, g == "D") |> cov_sum()
  )
```

```{r, fig.width=11, fig.height=6}
rdf |>
  ggplot(aes(x, y)) +
  geom_point(color="tomato", size=0.4, alpha=0.3) +
  facet_wrap(~g, labeller = as_labeller(labels), scales="free") +
  labs(x = NULL, y = NULL) +
  theme(legend.position="none")
```

## Korrelationskoeffizient

```{r, fig.width=11, fig.height=6}
rdf |>
  ggplot(aes(x, y)) +
  geom_rect(aes(xmin = -Inf, xmax = mx, ymin = my, ymax = Inf),  fill = "#dce8f5") +
  geom_rect(aes(xmin = mx, xmax = Inf, ymin = -Inf, ymax = my),  fill = "#dce8f5") +
  geom_rect(aes(xmin = -Inf, xmax = mx, ymin = -Inf, ymax = my), fill = "#f5e1dc") +
  geom_rect(aes(xmin = mx, xmax = Inf, ymin = my, ymax = Inf),   fill = "#f5e1dc") +
  geom_point(aes(color=color), size=0.4, alpha=0.3) +
  scale_color_manual(values=c("darkred", "navyblue")) +
  facet_wrap(~g, labeller = as_labeller(labels), scales="free") +
  labs(x = NULL, y = NULL) +
  theme(legend.position="none")
```


## Nichtlineare Zusammenhänge

```{r, fig.width=11, fig.height=6}
set.seed(123)
n = 30
d_cov = tibble(
  x = seq(-1, 1, length.out=n),
  y = -x^2 + rnorm(n, sd=0.2)
)

dat = d_cov
x_mean <- mean(dat$x)
y_mean <- mean(dat$y)
dat$color = factor(
  ((dat$x - x_mean) * (dat$y - y_mean)) > 0,
  levels = c(TRUE, FALSE),
  labels=c("pos", "neg")
)

dat |>
  ggplot(aes(x, y)) +
  geom_point(color="black", shape = 1,  stroke = 2) +
  labs(x = NULL, y = NULL) +
  theme(legend.position="none")

```


## Nichtlineare Zusammenhänge

```{r, fig.width=11, fig.height=6}
set.seed(123)
n = 30
d_cov = tibble(
  x = seq(-1, 1, length.out=n),
  y = -x^2 + rnorm(n, sd=0.2)
)

dat = d_cov
x_mean <- mean(dat$x)
y_mean <- mean(dat$y)
dat$color = factor(
  ((dat$x - x_mean) * (dat$y - y_mean)) > 0,
  levels = c(TRUE, FALSE),
  labels=c("pos", "neg")
)

dat |>
  ggplot(aes(x, y)) +
  annotate("rect", xmin = -Inf, xmax = x_mean, ymin = y_mean, ymax = Inf,  fill = "#dce8f5") +
  annotate("rect", xmin = x_mean, xmax = Inf, ymin = -Inf, ymax = y_mean,  fill = "#dce8f5") +
  annotate("rect", xmin = -Inf, xmax = x_mean, ymin = -Inf, ymax = y_mean, fill = "#f5e1dc") +
  annotate("rect", xmin = x_mean, xmax = Inf, ymin = y_mean, ymax = Inf,   fill = "#f5e1dc") +
  geom_point(aes(color = color), shape = 1,  stroke = 2) +
  scale_color_manual(values=c("darkred", "navyblue")) +
  labs(x = NULL, y = NULL) +
  theme(legend.position="none")

```


## Nichtlineare Zusammenhänge

```{r, fig.width=11, fig.height=6}
library(gapminder)

gapminder |>
  filter(year==2007) |>
  ggplot(aes(gdpPercap, lifeExp)) +
  # geom_hline(yintercept=0, color="grey60", linewidth=0.3) +
  # geom_vline(xintercept=0, color="grey60", linewidth=0.3) +
  geom_point(shape=1, color="tomato") +
  labs(
    x = "BIP",
    y = "Lebenserwartung (Jahre)",
    title = "Lebenserwartung und BIP",
    subtitle = "Daten für 142 Länder im Jahr 2007",
    caption = "Datenquelle: gampinder.org"
  )

```

## Transformationen

```{r, fig.width=11, fig.height=6}
d1 = gapminder |>
  filter(year==2007) 

p1 = d1|>
  ggplot(aes(gdpPercap, lifeExp)) +
  geom_point(shape=1, color="tomato") +
  labs(
    x = "BIP",
    y = "Lebenserwartung (Jahre)",
    title = "Ohne Log-Transformation",
    subtitle = paste(
      "r = ",
      round(cor(d1$gdpPercap, d1$lifeExp), digits=2),
      " | rₛ = ",
      round(cor(d1$gdpPercap, d1$lifeExp, method="spearman"), digits=2)
    ),
    x = NULL, y = NULL
  )

p2 = d1 |>
  ggplot(aes(log10(gdpPercap), lifeExp)) +
  geom_point(shape=1, color="tomato") +
  scale_x_continuous(
      breaks = c(1,2,3,4,5),
      labels = scales::math_format(10^.x)
  ) +
  labs(
    x = "BIP (Log-Skala)",
    y = NULL,
    title = "Mit Log-Transformation",
    subtitle = paste(
      "r = ",
      round(cor(log10(d1$gdpPercap), d1$lifeExp), digits=2),
      " | rₛ = ",
      round(cor(log10(d1$gdpPercap), d1$lifeExp, method="spearman"), digits=2)
    ),
    caption = "Datenquelle: gampinder.org"
  )

p1 | p2
```

## Rangkorrelationskoeffizient

Der *Rangkorrelationskoeffizient* ist der Korrelationskoeffizient der *Ränge* zweier Variablen. Für rangtransformierte Variablen $x_r$ und $y_r$ gilt also wie zuvor:

<!-- \textrm{cov}(\textrm{rang(x)}, \textrm{rang(y)}) -->
$$
r_s = \frac{
    s_{x_r, y_r}
  }{
    s_{x_r} s_{y_r}
}
$$

Der Rangkorrelationskoeffizient erfasst nicht nur lineare sondern auch nichtlineare aber monotone Zusammenhänge und kann auch für ordinale Variablen eingesetzt werden.

## Rangkorrelationskoeffizient

Die beiden Datenreihen

$$
\begin{align}
\color{orange}{x = 1{,}4 \quad 2{,}3 \quad 1{,}1 \quad 2{,}7 \quad}
\color{cornflowerblue}{y = 5{,}3 \quad 4{,}3 \quad 0{,}4 \quad 4{,}8}
\end{align}
$$

werden rangtransformiert zu:
$$
\begin{align}
\color{orange}{x_r = 3 \quad 2 \quad 4 \quad 1 \quad}
\color{cornflowerblue}{y_r = 1 \quad 3 \quad 4 \quad 2}
\end{align}
$$

Damit ergibt sich unter Anwendung der gleichen Schritte:

$$
r_s = \frac{ s_{x_r, y_r} }{ s_{x_r} s_{y_r} }
= \frac{0.67}{1.29 \times 1.29} = 0.4
$$


## Rangkorrelationskoeffizient

```{r, fig.width=11, fig.height=6}
set.seed(123)
n = 1000
d1 = tibble(
  x = seq(0.001, 0.5, length.out=n),
  x2 = seq(-1, 1, length.out=n),
  y1 = x + rnorm(n, sd=0.1),
  y2 = log(x) + rnorm(n, sd=0.1),
  y3 = -x2^2 + rnorm(n, sd=0.1)
)

p1 = d1 |>
  ggplot(aes(x, y1)) +
  geom_point(color="tomato", shape=1) +
  labs(
    title = paste(
      "r = ",
      round(cor(d1$x, d1$y1), digits=2),
      " | rₛ = ",
      round(cor(d1$x, d1$y1, method="spearman"), digits=2)
    ),
    x = NULL, y = NULL
  )

p2 = d1 |>
  ggplot(aes(x, y=y2)) +
  geom_point(color="cornflower blue", shape=1) +
  labs(
    title = paste(
      "r = ",
      round(cor(d1$x, d1$y2), digits=2),
      " | rₛ = ",
      round(cor(d1$x, d1$y2, method="spearman"), digits=2)
    ),
    x = NULL, y = NULL
  )

p3 = d1 |>
  ggplot(aes(x2, y=y3)) +
  geom_point(color="orange", shape=1) +
  labs(
    title = paste(
      "r = ",
      round(cor(d1$x2, d1$y3), digits=2),
      " | rₛ = ",
      round(cor(d1$x2, d1$y3, method="spearman"), digits=2)
    ),
    x = NULL, y = NULL
  )

p1 | p2 | p3

```

# Exkurs 
Räumliche Autokorrelation

## Räumliche Autokorrelation {.smaller}

Einkommsensverteilung in deutschen Großstädten (<span class="arrow-up">&#x2191;</span> <span class="arrow-down">&#x2193;</span>)

::::: columns
::: {.column width="50%"}
![Einkommen in München (Quelle: Zeit.de)](https://interactive.zeit.de/g/2022/stadtdaten/static/assets/09162000.5ef64850.png){.shadow height="400px"}
:::
::: {.column width="50%"}
![Einkommen in Köln (Quelle: Zeit.de)](https://interactive.zeit.de/g/2022/stadtdaten/static/assets/koeln-closeup.ad0efbdb.png){.shadow height="400px"}
:::
:::::

## Räumliche Autokorrelation

- Beispiel

## Räumliche Autokorrelation

- Einordnung

## Räumliche Gewichte

## Nachbarschaften

## Moran's I

Moran's $I$ misst die räumliche Autokorrelation einer Variable $x$ und Gewichten $w$ mit Summe $S_w = \sum_{i=1}^n \sum_{j=1}^n w_{ij}$ als:

$$
I = \frac{n}{S_w}
\frac{\sum_{i=1}^n \sum_{j=1}^n w_{ij}(x_i - \bar{x})(x_j - \bar{x})}{\sum_{i=1}^n (x_i-\bar{x})^2}
$$

Moran's I nimmt Werte im Bereich -1 (perfekte räumliche Antikorrelation) bis 1 (perfekte räumliche Korrelation) an. Neben dem globalen Index gibt es auch lokale Versionen des Maßes.

## Zeitliche Autokorrelation


# Zusammenhangsmaße
Kategorische Variablen

## Die Kontingenztabelle

```{r}
bes = readr::read_csv("data/BES.csv")
bes$education = factor(
  bes$education,
  levels = 1:5,
  labels = c(
    "Keine Qualifikation",
    "Realschulabschluss",
    "Abitur",
    "Bachelor",
    "Master"
  )
)
```

```{r}
library(janitor)
library(knitr)
library(kableExtra)

f = function(x) format(x, big.mark = " ")

bes |>
  rename(Bildung = education) |>
  filter(vote %in% c("stay", "leave")) |>
  drop_na() |>
  tabyl(Bildung, vote) |>
  adorn_totals(where = "both", name="Gesamt") |>
  adorn_percentages("row") |>
  adorn_pct_formatting(digits = 1) |>
  adorn_ns(position = "front", format_func = f) |>
  kable(align=c("l", "r", "r", "r")) |>
  kable_classic("hover") |>
  footnote(
    general="2016 BES Brexit Survey",
    general_title = "Quelle:",
    footnote_as_chunk=T
  ) |>
  kable_styling(font_size=28)
```

Eine Kontingenztabelle zeigt Beobachtungshäufigkeiten und Randhäufigkeiten (Reihen- und Spaltensummen) für alle Ausprägungskombinationen zweier kategorialer Variablen.

## Die Kontingenztabelle

```{r, fig.height=6, fig.width=11}
bes_p = bes |>
  filter(vote %in% c("stay", "leave")) |>
  drop_na()

p1 = bes_p |>
  ggplot(aes(vote, education)) +
  geom_jitter(alpha=0.3, size=0.3) +
  labs(x=NULL, y=NULL)

p2 = bes_p |>
  summarize(n=n(), .by=c(vote, education)) |>
  mutate(s = n / sum(n), .by=education) |>
  ggplot(aes(vote, education, fill=s)) +
  geom_tile(color="white", linewidth=5) +
  geom_text(aes(label=format(n, big.mark=" ")), size=4, color="grey40") +
  scale_fill_distiller(
    palette="RdBu",
    type="div",
    limit = c(0.0, 1.0),
    breaks = c(0.0, 0.5, 1.0),
    labels = scales::percent,
    guide = guide_colourbar(nbin = 100, draw.ulim = FALSE, draw.llim = FALSE)
  ) +
  guides(fill=guide_colorbar(barwidth=10, barheight=0.7)) +
  labs(x=NULL, y=NULL, fill=NULL)

p1 | p2
```

## Die Indifferenztabelle

```{r}
fr = function(x) format(x, big.mark = " ")

bes |>
  filter(vote %in% c("stay", "leave")) |>
  drop_na() |>
  summarize(n=n(), .by=c(education, vote)) |>
  mutate(Hg=sum(n)) |>
  mutate(Hr = sum(n), .by=education) |>
  mutate(Hc = sum(n), .by=vote) |>
  mutate(TH = round(Hr * Hc / Hg, 1)) |>
  arrange(education, vote) |>
  pivot_wider(
    id_cols=education,
    names_from = vote,
    values_from = TH
  ) |>
  rename(Bildung = education) |>
  adorn_totals(where = "both", name="Gesamt") |>
  adorn_percentages("row") |>
  adorn_pct_formatting(digits = 1) |>
  adorn_ns(position = "front", format_func = fr) |>
  kable(align=c("l", "r", "r", "r")) |>
  kable_classic("hover") |>
  footnote(
    general="2016 BES Brexit Survey",
    general_title = "Quelle:",
    footnote_as_chunk=T
  ) |>
  kable_styling(font_size=28)

```

Die Indifferenztabelle bildet theoretische Häufigkeiten unter der Annahme von Unabhängigkeit der beiden Variablen ab.

## Theoretische Häufigkeiten

Die theoretische Häufikgeit $H_{ij}^{(T)}$ für Reihe $i$ und Spalte $j$ ist bei $n$ Beobachtungen und mit Reihensumme $H_i^{(R)}$ und Spaltensumme $H_j^{(C)}$ gegeben durch:

$$
H_{ij}^{(T)} = \frac{H_i^{(R)} H_j^{(C)}}{n}
$$

Theoretische Häufikgeiten stellen eine Gleichverteilung unter Präservation der Randhäufigkeiten der beiden Variablen dar.


## Chi-Quadrat ($\chi^2$)

Der Chi-Quadrat-Koeffizient misst die Abweichungen der beobachteten von den theoretischen Häufigkeiten:

$$
\chi^2 = \sum_{i=1}^r \sum_{j=1}^c \frac{(H_{ij} - H_{ij}^{(T)})^2}{H_{ij}^{(T)}}
$$

$\chi^2$ ist abhängig von der Beobachtungsanzahl $n$ und weicht bei unterschiedlichen $n$ selbst bei identischen relativen Verteilungen ab.


## Kontingenzkoeffizient

Der *Kontingenzkoeffizient* $C$ normalisiert $\chi^2$ für beliebige $n$:

$$
C = \sqrt{\frac{\chi^2}{\chi^2 + n}}
$$

Wenn die theoretische und die beobachtete Verteilung identisch sind, ist $C=0$. Das Maximum ist immer < 1, der genaue Wert hängt aber von den Dimensionen der Tabelle ab.
<!-- Um ein oberes Limit von 1 zu erhalten, kann $C$ nochmals normalisiert werden: -->
<!---->
<!-- $$C_{korr} = \frac{C}{\sqrt{(k - 1)/k}}$$ -->

## Brexit und Bildung {.smaller}

:::: {.columns}
::: {.column width="45%"}
```{r}
f = function(x) format(x, big.mark = " ")

bes |>
  rename(Bildung = education) |>
  filter(vote %in% c("stay", "leave")) |>
  drop_na() |>
  tabyl(Bildung, vote) |>
  kable(align=c("l", "r", "r", "r")) |>
  kable_classic("hover") |>
  footnote(
    general="Beobachtet",
    general_title = "",
    footnote_as_chunk=T
  ) |>
  kable_styling(font_size=28)

```
:::
::: {.column width="55%"}
```{r}
bes |>
  filter(vote %in% c("stay", "leave")) |>
  drop_na() |>
  summarize(n=n(), .by=c(education, vote)) |>
  mutate(Hg=sum(n)) |>
  mutate(Hr = sum(n), .by=education) |>
  mutate(Hc = sum(n), .by=vote) |>
  mutate(TH = round(Hr * Hc / Hg, 1)) |>
  mutate(diff = n - TH) |>
  arrange(education, vote) |>
  pivot_wider(
    id_cols=education,
    names_from = vote,
    values_from = TH
  ) |>
  rename(Bildung = education) |>
  kable(align=c("l", "r", "r", "r")) |>
  kable_classic("hover") |>
  footnote(
    general="Theoretisch",
    general_title = "",
    footnote_as_chunk=T
  ) |>
  kable_styling(font_size=28, full_width=FALSE)
```

:::
::::

$$
\chi^2 =
\frac{(1356 - 874{,}9)^2}{847{,}9} + \ldots +
\frac{(1898 - 1335{,}6)^2}{1335{,}6}
= 2025{,}8 \\
C =
\sqrt{\frac{2025{,}8}{2025{,}8 + 25097}} = 0.27
$$


## Prüfungsfragen

- Welche Rolle spielen abhängige, unabhängige und Kontrollvariablen in multivariaten Analysen?

- Berechnen Sie den Korrelationskoeffizienten für die folgenden Datenreihen.

- Welches Zusammenhangsmaß nutzen Sie für zwei ordinale Variablen?

- Was ist der zentrale Vergleich der dem Kontingenzkoeffizienten zugrunde liegt?

